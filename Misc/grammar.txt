<Program> ::= <Preprocessor> { <Global Statement> }

<Preprocessor> ::= { import <Literal Constant> }

<Global Statement> ::= <Function> | <Var Definitions>; | <Namespace Definition> | <Struct Definition>

<Namespace Definition> ::= namespace <Identifier> '{' {<Global Statement>} '}'

<Struct Definition> ::= struct <Identifier> '{' {<Global Statement>}  '}' [<Vars> | eps];

<Function> ::= func <Identifier> ([<Arguments> | eps | void]) : <Concrete Type> [<Func Body> | ;]

<Type> ::= <Const Type> | <Concrete Type>
<Const Type> ::= const <Concrete Type>
<Concrete Type> ::= <Identifier> {@} {'['{,}']'}

<Arguments> ::= <Type> <Identifier> | <Type> <Identifier> , <Arguments>

<Func Body> ::= '{' {<Statement>} '}'

<Body> ::= <Func Body> | <Statement>

<Statement> ::= <Var Definitions>; | <Func Body> | <Expr>; | <goto>; | <if> | <switch> | <while> | <for> | <do while>;

<Var Definitions> ::= <Type> <Vars>
<Vars> ::= <Var Definition>, <Vars> | <Var Definition>
<Var Definition> ::= <Identifier> | <Identifier> = <Expr>

<Expr> ::= <Assignment Expr> | <Assignment Expr> , <Expr>
<Assignment Expr> ::= <Logical Implication> <Assignment Operator> <Init Expr> | <Logical Implication>
<Init Expr> ::= <Assignment Expr> | <Init List>
<Init List> ::= '{' <Init List Seq> '}'
<Init List Seq> ::= <Assignment Expr> | <Assignment Expr> , <Init List Seq>

<Logical Implication> ::= <Logical Or> -> <Logical Implication> | <Logical Or>
<Logical Or> ::= <Logical And> ['||' | or] <Logical Or> | <Logical And>
<Logical And> ::= <Bitwise Or> [&& | and] <Logical And> | <Bitwise Or>

<Bitwise Or> ::= <Bitwise Xor> '|' <Bitwise And> | <Bitwise Xor>
<Bitwise Xor> ::= <Bitwise And> [^ | xor] <Bitwise Xor> | <Bitwise And>
<Bitwise And> ::= <Comparison Equality> & <Bitwise And> | <Comparison Equality>

<Comparison Equality> ::= <Comparison Comparison> [== | !=] <Comparison Equality> | <Comparison Comparison>
<Comparison Comparison> ::= <Shift> [> | >= | < | <=] <Comparison Comparison> | <Shift>

<Shift> ::= <Sumsub> [>> | <<] <Shift> | <Sumsub>

<Sumsub> ::= <Muldiv> [+ | -] <Sumsub> | <Muldiv>

<Muldiv> ::= <Power> [/ | // | * || %] <Muldiv> | <Power>

<Power> ::= <Unary> ** <Power> | <Unary>

<Unary> ::= [++ | -- | ~ | ! | not | - | + | @ | ? | delete] <Unary> | new <Type Instance> | <GenSec>

<GenSec> ::= <Namespace> [++ | -- | '(' [<Assignment Expr> {, <Assignment Expr>} | eps] ')' | '[' <Assignment Expr> {, <Assignment Expr>} ']' | .<Attribute>] | cast '<' <Type> '>' '(' <Expr> ')' | <Namespace>

<Namespace> ::= $ <Identifier> | <Identifier> $ <Nested Namespace> | <Operand>
<Nested Namespace> ::= <Identifier> | <Identifier> $ <Nested Namespace>

<Operand> ::= ( <Expr> ) | <Identifier> | <Numeric Constant> | <Literal Constant>

<Assignment Operator> ::= = | <<= | >>= | += | ->= | -= | *= | **= | /= | //= | ^= | &= | |= | %=

<Attribute> ::= <Identifier> [ '(' [<Expr> | eps] ')' | '[' <Expr> ']' | .<Attribute> | eps];

<if> ::= if ( <Expr> ) <Body> <Else Alternatives>

<switch> ::= switch ( <Expr> ) '{' {case <Expr>: { [<Statement> | eps] } [default: { [<Statement> | eps] } | eps] '}'
 
<while> ::= while ( <Expr> ) <Body> [else <Body> | eps]

<for> ::= for ( [<Expr> | <Var Definitions> | eps]; [<Expr> | eps]; [<Expr> | eps] ) <Body> [else <Body> | eps]

<do while> ::= do <Body> while ( <Expr> )

<goto> ::= goto <Identifier> | break | continue | <return> | <Label Definition>

<return> ::= return [<Expr> | eps]

<Type Instance> ::= <Identifier> {@} {'[' [<Assignment Expr> {, <Assignment Expr>} | eps] ']'} 

<Label Definition> ::= label <Identifier>

<Else Alternatives: ::= else <Body> | elif (<Expr>) <Body> <Else Alternatives> | eps
